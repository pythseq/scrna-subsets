---
title: "Pick Cells for subsampling"
author: "Kent Riemondy RBI"
date: "March 23, 2017"
runtime: shiny
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
knitr::opts_chunk$set(message = FALSE)
```

## Basic details
10x genomic barcodes are designed to have a minimum hamming distances of 2. They use a set of barcodes (~800K) that must of been generated with a split pool type sythensis reaction. The problem with this, is that our PCR based subsampling strategy will likely not be able to distinguish between 2 nt differences. If the barcodes were fully randomized then it would be unlikely that two cell barcodes would be within a few hamming distances. (i.e. 1/4 ^ 16 probability for fully matching).

Austin came up with an alternative strategy that proposes to use biotinylated LNA oligos anti-sense to the cell barcode as bait to pull down the specific cell barcodes. The big advantage of this approach is that the original barcode will be present in the final libary, making determination of specificity straight-forward. 

## Pick some barcodes

The barcodes will be chosen from a set of mouse and human cells from the 10x genomics control NIH-3T3/293T mix single cell experiment. Ideally these barcodes will be present at low, medium, and high UMI counts. Additionally barcodes will be chosen that are absent or lowly represented in the other single cell datasets (Cambier and Jordan datasets). 





##


##

```{r show_data, message = F, warning = F}
library(cellrangerRkit)
library(dtplyr)
library(dplyr)
library(shiny)
library(purrr)
library(readr)
library(stringr)
library(Rtsne)
library(kentr) # collection of simple seq utilities to be put on github once more mature
```

```{r compress, eval = T}
## compression scheme used by 10x, function below is an internal function taken from their package

#' Compress a vector of sequences into 2-bit representation
#'
#' Compress a vector of sequences into integer64 objects containing
#' a 2-bit representation. Ns are not allowed
#' @param seqs Vector of nucleotide sequences to compress
#' @return A vector of integer64 objects
compress_sequences <- function(seqs) {
  if (any(grepl('[^ACGT]', seqs))) {
    stop("At least one sequence contains Ns")
  }
  nuc_to_int <- as.integer(0:3)
  names(nuc_to_int) <- c('A', 'C', 'G', 'T')

  chars <- do.call(rbind, strsplit(seqs, ''))
  nuc_ints <- matrix(nuc_to_int[chars], nrow=length(seqs))
  result <- integer64(length(seqs))
  for(i in 1:ncol(nuc_ints)) {
    result <- result * as.integer(4) + nuc_ints[,i]
  }

  result
}
```

```{r custom_decompressing}
#write a custom decompressing function in R

#' decompress the 10x encoded barcodes. 
#' @param seqs_int64 Vector of int64 2bit encoded sequences to decompress
#' @param lens Length of compressed barcode (int)
#' @return A vector of DNA sequences

decompress_sequences <- function(seqs, lens){
  # hacky and takes about 15 seconds per 1e6  sequences
  bit_code <- c('A', 'C', 'G', 'T')
  names(bit_code) <- c("00", "01", "10", "11")

  b <- as.bitstring(seqs)
  b <- do.call(rbind, strsplit(b, ""))
  nbit <- lens * 2
  nbit_pos <- 64 - (nbit - 1)
  b <- b[, nbit_pos:64]
  pos <- seq(1, nbit, by = 2)
  result = ""
  for(i in pos){
     x <- paste0(b[, i], b[, (i + 1)])
     x_n <- bit_code[x]
     result <- paste0(result, x_n)
  }
  result
}

seqs <- c("ATCG", "GGAT", "CTGA", "TGAC")
seqs_binary <- compress_sequences(seqs)
out_seqs <- decompress_sequences(seqs_binary, 4)
all(seqs == out_seqs)
```


## Per barcode stats

The number of umis and reads per barcode is stored in the molecule_info.h5 file, which can be parsed via the cellrangerkit ``load_molecule_info()`` function. After loading and decompressing the seqs, the number of reads, UMIs, and duplication rates are calculated and saved as `per_cell_summary.txt.gz`. For this analysis I've decided to compare againt the AML samples from Craig Jordans lab, specifically AML1, which has the most barcodes detected (110,742).

```{r utils}
load_dat <- function(sample_id, genome){
  gbm <- load_cellranger_matrix(paste0("~/Projects/10x_scRNA/data/", sample_id), genome = genome)
  gbm <- load_molecule_info(gbm = gbm) #load from h5 file
  dat <- gbm@molecule_info #extracted as a data.table 
  dat
}

summarize_barcodes <- function(data_object, analysis_object){
  data_object  %>% 
  group_by(seqs) %>% 
  summarize(total_umis = n(), total_reads = as.integer(sum(reads))) %>% 
  as_data_frame() %>% 
  mutate(dup_rate = 1 - (total_umis / total_reads)) %>%  
  arrange(desc(total_umis)) %>% 
  ungroup() -> dat_stats 
  dat_stats  
}
```


```{r}
# no need to run on control + hg19 again, as the counts are all duplicates
samples <- list(
  "control",
  "Jordan/Brett_1"
)
genomes <- c("mm10", "GRCh38")

sample_names <- transpose(list(genomes, samples)) %>% 
  map(~paste(.x, collapse = "_")) %>% 
  str_replace("/", "_")
```

```{r process_bcs, cache.lazy= F, eval = F}
dat <- map2(samples, genomes, ~load_dat(.x, .y))

names(dat) <- sample_names

#analysis <- map(samples, 
#                ~load_cellranger_analysis_results(paste0("~/Projects/10x_scRNA/data/", .x)))
 
# get unique barcodes (~100k) 
seqs <- map(dat, ~select(.x, barcode) %>% unique())

# Decode the barcode slow!
seqs <- map(seqs, ~mutate(.x, seqs = decompress_sequences(barcode, 16)))

# join seqs with dat
dat <- map2(dat, seqs, ~inner_join(.x, .y, by = "barcode"))

# append to gem Id to barcode seq to match matrix colnames
dat <- map(dat, ~mutate(.x, seqs = paste0(seqs, "-", gem_group)) %>% tbl_df()) 

dat <- map(dat, ~summarize_barcodes(.x))
dat <- bind_rows(dat, .id = "library")
write_gztsv(dat, "per_cell_summary.txt.gz")
```


## Determine shared barcodes

Next, each barcode in the mouse/human experiment is compared to the Jordan lab AML experiment.

```{r}
dat <- read_tsv("per_cell_summary.txt.gz")
# split by group and compare vectors
split(dat, dat$library) -> tmp
tmp[[1]]$shared <- tmp[[1]]$seqs %in% tmp[[2]]$seqs
tmp[[2]]$shared <-  tmp[[2]]$seqs %in% tmp[[1]]$seqs

grp_dat_by_expt <- bind_rows(tmp)

grp_dat_by_expt %>% 
  group_by(library) %>%  
  summarize(barcodes_detected_in_both_libs = sum(shared))
```

a large proportion are shared between the experiments. Mostly due to rare barcodes with few reads. Next check the number of shared barcodes that were considered as cells. 

```{r}
# get data object
matrix_dat <- map2(samples, genomes, 
                ~load_cellranger_matrix(paste0("~/Projects/10x_scRNA/data/", .x), genome = .y))

# extract out barcodes
cell_bcs <- map(matrix_dat, ~data_frame(good_cell_bcs = as.character(.x@phenoData@data$barcode)))
names(cell_bcs) <- sample_names
cell_bcs <- bind_rows(cell_bcs, .id = "library")

# keep only cell bcs
cell_dat <- semi_join(grp_dat_by_expt, 
          cell_bcs, 
          by = c("library", "seqs" = "good_cell_bcs"))

# compare bcs between groups
split(cell_dat, cell_dat$library) -> tmp
tmp$aml$cells_shared <- tmp$aml$seqs %in% tmp$mouse_human$seqs
tmp$mouse_human$cells_shared <- tmp$mouse_human$seqs %in% tmp$aml$seqs
cell_dat <- bind_rows(tmp)

# how many cell bcs shared
cell_dat %>% 
  group_by(library) %>%  
  summarize(barcodes_detected_in_both_libs = sum(cells_shared))
```

Only 4 cellular barcodes are shared between the libraries, but instead I'll try selecting cells based on relative proportions. For example only pick cell barcodes that are not found in the top quartile of the other library or some other similar method. 

```{r}

grp_dat_by_expt %>% 
  group_by(library) %>% 
  mutate(total_reads_per_expt = sum(total_reads),
    proportional_read_count = total_reads / total_reads_per_expt,
    quartile_rank_reads = ntile(proportional_read_count, 4),
    percent_rank_reads = percent_rank(proportional_read_count),
    rank = min_rank(desc(proportional_read_count))) %>% 
  dplyr::select(-total_reads_per_expt) -> grp_dat_by_expt

grp_dat_by_expt %>% 
  dplyr::filter(quartile_rank_reads == 4) -> filter_dat

split(filter_dat, filter_dat$library) -> tmp
tmp[[1]]$shared <- tmp[[1]]$seqs %in% tmp[[2]]$seqs
tmp[[2]]$shared <-  tmp[[2]]$seqs %in% tmp[[1]]$seqs
filter_dat <- bind_rows(tmp)

# how many cell bcs shared
filter_dat %>% 
  group_by(library) %>%  
  summarize(barcodes_detected_in_both_libs = sum(shared))

```  

Lastly, reannotate which cells are mouse or human

```{r}

species_classification <- readr::read_csv("~/Projects/10x_scRNA/data/control/outs/analysis/gem_classification.csv")

# keep barcodes not shared in libraries
filtered <- filter(filter_dat, !shared)

# keep barcodes called as cells in mouse human expt, and add species
filtered <- inner_join(filtered, species_classification, by = c("seqs" = "barcode"))

filtered <- mutate(filtered, 
       purity = hg19 / total_umis) %>% 
  ungroup()

## add in hamming distance info
dat %>% 
  filter(library == "mm10_control") -> mouse_human_expt

# calc all pairwise hamming distances and generate logical matrix indicating which
# sequences are equal to the minimum  discovered hamming dist. Slow, 1-2 minutes

map(filtered$seqs, 
    ~kentr::get_hamming(.x, mouse_human_expt$seqs)) %>%  
  map(~min(.x[.x > 0]) == .x) -> hamming_distances

# find the indexes within the original barcode data that are equal to two
hdist_idxs <- map(hamming_distances, ~which(.x))

# get barcode with highest total-read count with hamming dist 2
best_match_bc <- map_df(hdist_idxs, ~mouse_human_expt[.x, ] 
                     %>% arrange(desc(total_umis)) 
                     %>% slice(1))

#rename to allow binding with output data
best_match_bc <- dplyr::rename(best_match_bc,
                               nearest_barcode = seqs,
                               nearest_total_umis = total_umis,
                               nearest_total_reads = total_reads
                               ) %>% dplyr::select(-library, -dup_rate)
#append to original data, row order is the same
filtered <- bind_cols(filtered, best_match_bc)

#add in hamming dists 
rowwise(filtered) %>% 
  mutate(., hamming_dist = get_hamming(seqs, nearest_barcode)) %>% 
  ungroup() -> filtered
filtered
```
## Cells picked based on shiny app

```{r, echo = FALSE, cache = FALSE, eval = T}

library(ggplot2)
#taken from http://shiny.rstudio.com/gallery/plot-interaction-basic.html

ui <- fluidPage(
  # Some custom CSS for a smaller font for preformatted text
  tags$head(
    tags$style(HTML("
      pre, table.table {
        font-size: smaller;
      }
    "))
  ),

  fluidRow(
    column(width = 12,
      # In a plotOutput, passing values for click, dblclick, hover, or brush
      # will enable those interactions.
      plotOutput("plot1", height = 350,
        # Equivalent to: click = clickOpts(id = "plot_click")
        click = "plot_click",
        dblclick = dblclickOpts(
          id = "plot_dblclick"
        ),
        hover = hoverOpts(
          id = "plot_hover"
        ),
        brush = brushOpts(
          id = "plot_brush"
        )
      )
    )
  ),
  fluidRow(
    column(width = 12,
      verbatimTextOutput("click_info")
    ),
    column(width = 3,
      verbatimTextOutput("dblclick_info")
    ),
    column(width = 3,
      verbatimTextOutput("hover_info")
    ),
    column(width = 3,
      verbatimTextOutput("brush_info")
    )
  )
)


server <- function(input, output) {
  output$plot1 <- renderPlot({
      ggplot(filtered, aes(hg19, mm10)) +
        geom_point(aes(color = call)) 
  })

  output$click_info <- renderPrint({
    if (length(input$plot_brush) > 0){
      filter(filtered, 
           hg19 >= input$plot_brush$xmin, 
           hg19 <= input$plot_brush$xmax, 
           mm10 >= input$plot_brush$ymin,
           mm10 <= input$plot_brush$ymax) %>% 
        select(seqs, dup_rate, purity, rank, nearest_barcode, nearest_total_reads) %>% 
        as.data.frame
    } else {
      cat("select cells")
    }
  })


}

shinyApp(ui, server)
```

Based on some interactive shiny analysis, cells were picked that spanned high, med, and low umi counts

```{r}

cells <-c(
  high_human ="CTGATCCCATGACGGA-1", # also matches rank 231  barcode CAGATCACATGACGGA with hdist 2
  med_human = "CCTCTGACACCAACCG-1",
  low_human = "TACGGGCCATAGTAAG-1",
  high_mouse = "GACGTTAGTGCCTGTG-1",
  med_mouse = "TGCGCAGCATTAACCG-1",
  low_mouse = "CTACACCCAAGGACAC-1"
  )

cells
```

```{r, eval = T}
DT::datatable(filter(filtered, seqs %in% cells))

```


## oligo information

Oligos from 10x rep:

5' P5-R1-Barcode: AATGATACGGCGACCACCGAGATCT-ACACTCTTTCCCTACACGACGCTCTTCCGATCT-NNNNNNNNNNNNNNNN 
3' P7-SI-R2: CAAGCAGAAGACGGCATACGAGAT-NNNNNNNN-GTGACTGGAGTTCAGACGTGTGCTCTTCCGATC

The 10x libraries have 4 unique indexes on the p7 primer for every sample. 

Then do the second round of PCR to introduce the p5 and p7 cluster formation seqs and whatever index(es) we want

```
P5~~~~~~~~~~primer1~~~>
       ~~~~~~~~~~~~~~~cell-barcode-umi ~~~~~~~~~~~~~~~~~~~~~~~ p7 adaptor sequence ~~~~
```


```{r oligo_picker, eval = T}
library(stringr)
library(readr)

p5_seq_full <- "AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCTNNNNNNNNNNNNNNNN"
p5_seq_no_cbc <- "AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT"
p5_seq_1 <- "AATGATACGGCGACCACCGAGATCT"
p5_seq_2 <- "ACACTCTTTCCCTACACGACGCTCTTCCGATCT"
cbc <- "NNNNNNNNNNNNNNNN"

p3_seq_full <- "CAAGCAGAAGACGGCATACGAGATNNNNNNNNGTGACTGGAGTTCAGACGTGTGCTCTTCCGATC"
p3_seq_2 <- "GTGACTGGAGTTCAGACGTGTGCTCTTCCGATC"
p3_seq_1 <- "CAAGCAGAAGACGGCATACGAGAT"
index <- "NNNNNNNN"

seqs <- list(p5_seq_full,
     p5_seq_no_cbc,
     p5_seq_1,
     p5_seq_2,
     cbc,
     p3_seq_full,
     p3_seq_2,
     p3_seq_1,
     index)

TruSeq_Universal_Adapter <- "AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT"
KR2_PEPCRPrimer_1.0 <- "AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT"
TruSeq_Universal_Adapter == p5_seq_no_cbc
KR2_PEPCRPrimer_1.0 == p5_seq_no_cbc
purrr::map(seqs, ~nchar(.x))
```

```{r}
revcomp_dna <- function(dna_string, rev = T) {
  lookup_tbl <- c("A", "T", "G", "C", "N")
  names(lookup_tbl) <- c("T", "A", "C", "G", "N")
  if (rev){
      purrr::map(str_split(dna_string, "", simplify = T), 
             ~lookup_tbl[.x]) %>% 
      rev(.) %>% 
      str_c(., collapse = "") -> res
  } else {
      purrr::map(str_split(dna_string, "", simplify = T), 
             ~lookup_tbl[.x]) %>% 
      str_c(., collapse = "") -> res
  }
  res
}

revcomp_dna(TruSeq_Universal_Adapter) %>% revcomp_dna(.) -> test_string
test_string == TruSeq_Universal_Adapter
revcomp_dna(p3_seq_full)
TruSeq_Index_Adapter <- "GATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG" #taken from  illumina docs, added two NNs in index
revcomp_dna(p3_seq_full) == TruSeq_Index_Adapter
```

The P5-R1-barcode primer is the TruSeq_universal_adapter sequence + a 16bp cell barcode

The P7-S1-R2 is similar to the reverse complement of the TruSeq_index_adapter. The only difference is an 8bp index rather than a 6bp.


